#include "magix_vm/compilation/instruction_data.hpp"

#include <unordered_map>

namespace
{

const magix::compile::PseudoInstructionTranslation remap_table[] = {
{%- set remap_data = namespace(counter = 0, begin = {}, end = {}, reg_map = {}, reg_counter = 0) %}
{%- for inst in instructions if inst.get("pseudo",False) %}
    // BEGIN {{inst.mnenomic}}
{%- set _dummy = remap_data.begin.update({ inst.mnenomic : remap_data.counter}) %}
{%- set remap_data.reg_map = {} %}
{%- set remap_data.reg_counter = 0 %}
{%- for reg in inst.registers %}
{%- set _dummy = remap_data.reg_map.update({ reg.name : remap_data.reg_counter})%}
{%- set remap_data.reg_counter = remap_data.reg_counter + 1 %}
{%- endfor %}
{%- for emitted in inst.mapping %}
{%- set remap_data.counter = remap_data.counter + 1 %}
    {
        U"{{emitted.mnenomic}}",
        {
{%- for reg in emitted.registers %}
            {
{%- if reg.action == "copy" %}
                magix::compile::InstructionRegisterRemap::RemapType::COPY,
                {{ remap_data.reg_map[reg.src] }},
{%- elif reg.action == "immediate" %}
                magix::compile::InstructionRegisterRemap::RemapType::FIXED_IMMEDIATE,
                {{reg.value}},
{%- elif reg.action == "local" %}
                magix::compile::InstructionRegisterRemap::RemapType::FIXED_LOCAL,
                {{reg.value}},
{%- endif %}
                {{reg.offset}},
            },
{%- endfor %}
        },
    },
{%- endfor %}
{%- set _dummy = remap_data.end.update({ inst.mnenomic : remap_data.counter}) %}
    // END {{inst.mnenomic}}
{%- endfor %}
};

const magix::compile::InstructionSpec inst_table[] = {
{%- for inst in instructions %}
    {
        U"{{inst.mnenomic}}",
{%- if inst.get("pseudo", False) %}
        true,
        magix::invalid_opcode,
{%- else %}
        false,
        {{inst.opcode}},
{%- endif %}
        {
{%- for reg in inst.registers %}
            {
{%- if reg.mode == "stack" %}
                magix::compile::InstructionRegisterSpec::Mode::LOCAL,
{%- elif reg.mode == "immediate" %}
                magix::compile::InstructionRegisterSpec::Mode::IMMEDIATE,
{%- else%}
{{None['register mode %s invalid' % reg.mode]}}
{%- endif%}
                magix::compile::InstructionRegisterSpec::Type::{{reg.type | upper}},
                U"{{reg.name}}",
            },
{%- endfor %}
        },
{%- if inst.get("pseudo", False) %}
        {&remap_table[{{remap_data.begin[inst.mnenomic]}}], &remap_table[{{remap_data.end[inst.mnenomic]}}]},
{%- else %}
        {nullptr, nullptr},
{%- endif %}
    },
{%- endfor %}
};

const std::unordered_map<std::basic_string<magix::compile::SrcChar>, const magix::compile::InstructionSpec *> name_map = {
{%- for inst in instructions %}
    { U"{{inst.mnenomic}}", &inst_table[{{loop.index0}}] },
{%- endfor %}
};

} // namespace

[[nodiscard]] auto
magix::compile::get_instruction_spec(SrcView instruction_name) -> const magix::compile::InstructionSpec *
{
    std::basic_string<SrcChar> key{instruction_name};
    if (auto it = name_map.find(key); it != name_map.end())
    {
        return it->second;
    }
    return nullptr;
}

[[nodiscard]] auto
magix::compile::all_instruction_specs() noexcept -> magix::span<const magix::compile::InstructionSpec>
{
    return inst_table;
}
